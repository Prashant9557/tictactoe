{"ast":null,"code":"import React,{useState,useEffect}from\"react\";//use state and useEffect are hooks from the react package, used for managing side effects and state in functional components\nimport Board from\"./Board\";import Status from\"./Status\";import\"./Game.css\";//gridsize: the size of game grid, winstreak: the number of symbols in a row needed to win.\n//Board: represent the game board initialized as a 2D array and filled with null values.\nimport{jsxs as _jsxs,jsx as _jsx}from\"react/jsx-runtime\";const Game=_ref=>{let{gridSize,winStreak}=_ref;const[board,setBoard]=useState(Array(gridSize).fill(null).map(()=>Array(gridSize).fill(null)));//xIsNext: a boolean state to track which player turn it is, initialiozed as true becouse x is start the game.\n//winner: store the winner initialized as null.\n//isDraw: indicate that the game ended ia a draw initialized as false.\nconst[xIsNext,setXIsNext]=useState(true);const[winner,setWinner]=useState(null);const[isDraw,setIsDraw]=useState(false);//this use effect set a css variable to the --grid-size value whenever gridsize changes, it works dynamically based on the size of game grid.\nuseEffect(()=>{document.documentElement.style.setProperty(\"--grid-size\",gridSize);},[gridSize]);//handleClick is called when a cell is clicked. it takes row and column indexes of the clicked cell as argument. and checks for a winner or draw after each move.\nconst handleClick=(row,col)=>{if(board[row][col]||winner||isDraw)return;const newBoard=board.map((r,rowIndex)=>r.map((cell,colIndex)=>{if(rowIndex===row&&colIndex===col){return xIsNext?\"X\":\"O\";}return cell;}));setBoard(newBoard);setXIsNext(!xIsNext);if(checkWin(newBoard,winStreak)){setWinner(xIsNext?\"X\":\"O\");}else if(checkDraw(newBoard)){setIsDraw(true);}};//this will check the current move results in a win. it iterates through all possible direction to check if there is a winning streak.\nconst checkWin=(board,winStreak)=>{const directions=[[0,1],// horizontal\n[1,0],// vertical\n[1,1],// diagonal \\\n[1,-1]// diagonal /\n];const isWinningLine=line=>{return line.every(cell=>cell&&cell===line[0]);};for(let row=0;row<gridSize;row++){for(let col=0;col<gridSize;col++){for(let[dx,dy]of directions){const line=[];for(let i=0;i<winStreak;i++){const x=row+i*dx;const y=col+i*dy;if(x<0||x>=gridSize||y<0||y>=gridSize)break;line.push(board[x][y]);}if(line.length===winStreak&&isWinningLine(line)){return true;}}}}return false;};// tis functin checks if the game board is full and there is no winner , indicating a draw.\nconst checkDraw=board=>{return board.flat().every(cell=>cell!==null);};//this reset the game board and state to start a new game.\nconst handleReset=()=>{setBoard(Array(gridSize).fill(null).map(()=>Array(gridSize).fill(null)));setXIsNext(true);setWinner(null);setIsDraw(false);};return/*#__PURE__*/_jsxs(\"div\",{children:[/*#__PURE__*/_jsxs(\"h2\",{children:[\"Grid Size: \",gridSize,\", Win Streak: \",winStreak]}),/*#__PURE__*/_jsx(Board,{board:board,onClick:handleClick}),/*#__PURE__*/_jsx(Status,{winner:winner,isDraw:isDraw,xIsNext:xIsNext,onReset:handleReset})]});};export default Game;","map":{"version":3,"names":["React","useState","useEffect","Board","Status","jsxs","_jsxs","jsx","_jsx","Game","_ref","gridSize","winStreak","board","setBoard","Array","fill","map","xIsNext","setXIsNext","winner","setWinner","isDraw","setIsDraw","document","documentElement","style","setProperty","handleClick","row","col","newBoard","r","rowIndex","cell","colIndex","checkWin","checkDraw","directions","isWinningLine","line","every","dx","dy","i","x","y","push","length","flat","handleReset","children","onClick","onReset"],"sources":["C:/Users/Prash/OneDrive/Desktop/tictactoe react app/tictactoe/src/components/Game.js"],"sourcesContent":["import React, { useState, useEffect } from \"react\";\r\n//use state and useEffect are hooks from the react package, used for managing side effects and state in functional components\r\nimport Board from \"./Board\";\r\nimport Status from \"./Status\";\r\nimport \"./Game.css\";\r\n//gridsize: the size of game grid, winstreak: the number of symbols in a row needed to win.\r\n\r\n//Board: represent the game board initialized as a 2D array and filled with null values.\r\nconst Game = ({ gridSize, winStreak }) => {\r\n  const [board, setBoard] = useState(\r\n    Array(gridSize)\r\n      .fill(null)\r\n      .map(() => Array(gridSize).fill(null))\r\n  );\r\n  //xIsNext: a boolean state to track which player turn it is, initialiozed as true becouse x is start the game.\r\n  //winner: store the winner initialized as null.\r\n  //isDraw: indicate that the game ended ia a draw initialized as false.\r\n  const [xIsNext, setXIsNext] = useState(true);\r\n  const [winner, setWinner] = useState(null);\r\n  const [isDraw, setIsDraw] = useState(false);\r\n\r\n  //this use effect set a css variable to the --grid-size value whenever gridsize changes, it works dynamically based on the size of game grid.\r\n  useEffect(() => {\r\n    document.documentElement.style.setProperty(\"--grid-size\", gridSize);\r\n  }, [gridSize]);\r\n\r\n  //handleClick is called when a cell is clicked. it takes row and column indexes of the clicked cell as argument. and checks for a winner or draw after each move.\r\n  const handleClick = (row, col) => {\r\n    if (board[row][col] || winner || isDraw) return;\r\n\r\n    const newBoard = board.map((r, rowIndex) =>\r\n      r.map((cell, colIndex) => {\r\n        if (rowIndex === row && colIndex === col) {\r\n          return xIsNext ? \"X\" : \"O\";\r\n        }\r\n        return cell;\r\n      })\r\n    );\r\n\r\n    setBoard(newBoard);\r\n    setXIsNext(!xIsNext);\r\n\r\n    if (checkWin(newBoard, winStreak)) {\r\n      setWinner(xIsNext ? \"X\" : \"O\");\r\n    } else if (checkDraw(newBoard)) {\r\n      setIsDraw(true);\r\n    }\r\n  };\r\n\r\n  //this will check the current move results in a win. it iterates through all possible direction to check if there is a winning streak.\r\n  const checkWin = (board, winStreak) => {\r\n    const directions = [\r\n      [0, 1], // horizontal\r\n      [1, 0], // vertical\r\n      [1, 1], // diagonal \\\r\n      [1, -1], // diagonal /\r\n    ];\r\n\r\n    const isWinningLine = (line) => {\r\n      return line.every((cell) => cell && cell === line[0]);\r\n    };\r\n\r\n    for (let row = 0; row < gridSize; row++) {\r\n      for (let col = 0; col < gridSize; col++) {\r\n        for (let [dx, dy] of directions) {\r\n          const line = [];\r\n          for (let i = 0; i < winStreak; i++) {\r\n            const x = row + i * dx;\r\n            const y = col + i * dy;\r\n            if (x < 0 || x >= gridSize || y < 0 || y >= gridSize) break;\r\n            line.push(board[x][y]);\r\n          }\r\n          if (line.length === winStreak && isWinningLine(line)) {\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  };\r\n\r\n  // tis functin checks if the game board is full and there is no winner , indicating a draw.\r\n  const checkDraw = (board) => {\r\n    return board.flat().every((cell) => cell !== null);\r\n  };\r\n\r\n  //this reset the game board and state to start a new game.\r\n  const handleReset = () => {\r\n    setBoard(\r\n      Array(gridSize)\r\n        .fill(null)\r\n        .map(() => Array(gridSize).fill(null))\r\n    );\r\n    setXIsNext(true);\r\n    setWinner(null);\r\n    setIsDraw(false);\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <h2>\r\n        Grid Size: {gridSize}, Win Streak: {winStreak}\r\n      </h2>\r\n      <Board board={board} onClick={handleClick} />\r\n      <Status\r\n        winner={winner}\r\n        isDraw={isDraw}\r\n        xIsNext={xIsNext}\r\n        onReset={handleReset}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Game;\r\n"],"mappings":"AAAA,MAAO,CAAAA,KAAK,EAAIC,QAAQ,CAAEC,SAAS,KAAQ,OAAO,CAClD;AACA,MAAO,CAAAC,KAAK,KAAM,SAAS,CAC3B,MAAO,CAAAC,MAAM,KAAM,UAAU,CAC7B,MAAO,YAAY,CACnB;AAEA;AAAA,OAAAC,IAAA,IAAAC,KAAA,CAAAC,GAAA,IAAAC,IAAA,yBACA,KAAM,CAAAC,IAAI,CAAGC,IAAA,EAA6B,IAA5B,CAAEC,QAAQ,CAAEC,SAAU,CAAC,CAAAF,IAAA,CACnC,KAAM,CAACG,KAAK,CAAEC,QAAQ,CAAC,CAAGb,QAAQ,CAChCc,KAAK,CAACJ,QAAQ,CAAC,CACZK,IAAI,CAAC,IAAI,CAAC,CACVC,GAAG,CAAC,IAAMF,KAAK,CAACJ,QAAQ,CAAC,CAACK,IAAI,CAAC,IAAI,CAAC,CACzC,CAAC,CACD;AACA;AACA;AACA,KAAM,CAACE,OAAO,CAAEC,UAAU,CAAC,CAAGlB,QAAQ,CAAC,IAAI,CAAC,CAC5C,KAAM,CAACmB,MAAM,CAAEC,SAAS,CAAC,CAAGpB,QAAQ,CAAC,IAAI,CAAC,CAC1C,KAAM,CAACqB,MAAM,CAAEC,SAAS,CAAC,CAAGtB,QAAQ,CAAC,KAAK,CAAC,CAE3C;AACAC,SAAS,CAAC,IAAM,CACdsB,QAAQ,CAACC,eAAe,CAACC,KAAK,CAACC,WAAW,CAAC,aAAa,CAAEhB,QAAQ,CAAC,CACrE,CAAC,CAAE,CAACA,QAAQ,CAAC,CAAC,CAEd;AACA,KAAM,CAAAiB,WAAW,CAAGA,CAACC,GAAG,CAAEC,GAAG,GAAK,CAChC,GAAIjB,KAAK,CAACgB,GAAG,CAAC,CAACC,GAAG,CAAC,EAAIV,MAAM,EAAIE,MAAM,CAAE,OAEzC,KAAM,CAAAS,QAAQ,CAAGlB,KAAK,CAACI,GAAG,CAAC,CAACe,CAAC,CAAEC,QAAQ,GACrCD,CAAC,CAACf,GAAG,CAAC,CAACiB,IAAI,CAAEC,QAAQ,GAAK,CACxB,GAAIF,QAAQ,GAAKJ,GAAG,EAAIM,QAAQ,GAAKL,GAAG,CAAE,CACxC,MAAO,CAAAZ,OAAO,CAAG,GAAG,CAAG,GAAG,CAC5B,CACA,MAAO,CAAAgB,IAAI,CACb,CAAC,CACH,CAAC,CAEDpB,QAAQ,CAACiB,QAAQ,CAAC,CAClBZ,UAAU,CAAC,CAACD,OAAO,CAAC,CAEpB,GAAIkB,QAAQ,CAACL,QAAQ,CAAEnB,SAAS,CAAC,CAAE,CACjCS,SAAS,CAACH,OAAO,CAAG,GAAG,CAAG,GAAG,CAAC,CAChC,CAAC,IAAM,IAAImB,SAAS,CAACN,QAAQ,CAAC,CAAE,CAC9BR,SAAS,CAAC,IAAI,CAAC,CACjB,CACF,CAAC,CAED;AACA,KAAM,CAAAa,QAAQ,CAAGA,CAACvB,KAAK,CAAED,SAAS,GAAK,CACrC,KAAM,CAAA0B,UAAU,CAAG,CACjB,CAAC,CAAC,CAAE,CAAC,CAAC,CAAE;AACR,CAAC,CAAC,CAAE,CAAC,CAAC,CAAE;AACR,CAAC,CAAC,CAAE,CAAC,CAAC,CAAE;AACR,CAAC,CAAC,CAAE,CAAC,CAAC,CAAG;AAAA,CACV,CAED,KAAM,CAAAC,aAAa,CAAIC,IAAI,EAAK,CAC9B,MAAO,CAAAA,IAAI,CAACC,KAAK,CAAEP,IAAI,EAAKA,IAAI,EAAIA,IAAI,GAAKM,IAAI,CAAC,CAAC,CAAC,CAAC,CACvD,CAAC,CAED,IAAK,GAAI,CAAAX,GAAG,CAAG,CAAC,CAAEA,GAAG,CAAGlB,QAAQ,CAAEkB,GAAG,EAAE,CAAE,CACvC,IAAK,GAAI,CAAAC,GAAG,CAAG,CAAC,CAAEA,GAAG,CAAGnB,QAAQ,CAAEmB,GAAG,EAAE,CAAE,CACvC,IAAK,GAAI,CAACY,EAAE,CAAEC,EAAE,CAAC,EAAI,CAAAL,UAAU,CAAE,CAC/B,KAAM,CAAAE,IAAI,CAAG,EAAE,CACf,IAAK,GAAI,CAAAI,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGhC,SAAS,CAAEgC,CAAC,EAAE,CAAE,CAClC,KAAM,CAAAC,CAAC,CAAGhB,GAAG,CAAGe,CAAC,CAAGF,EAAE,CACtB,KAAM,CAAAI,CAAC,CAAGhB,GAAG,CAAGc,CAAC,CAAGD,EAAE,CACtB,GAAIE,CAAC,CAAG,CAAC,EAAIA,CAAC,EAAIlC,QAAQ,EAAImC,CAAC,CAAG,CAAC,EAAIA,CAAC,EAAInC,QAAQ,CAAE,MACtD6B,IAAI,CAACO,IAAI,CAAClC,KAAK,CAACgC,CAAC,CAAC,CAACC,CAAC,CAAC,CAAC,CACxB,CACA,GAAIN,IAAI,CAACQ,MAAM,GAAKpC,SAAS,EAAI2B,aAAa,CAACC,IAAI,CAAC,CAAE,CACpD,MAAO,KAAI,CACb,CACF,CACF,CACF,CACA,MAAO,MAAK,CACd,CAAC,CAED;AACA,KAAM,CAAAH,SAAS,CAAIxB,KAAK,EAAK,CAC3B,MAAO,CAAAA,KAAK,CAACoC,IAAI,CAAC,CAAC,CAACR,KAAK,CAAEP,IAAI,EAAKA,IAAI,GAAK,IAAI,CAAC,CACpD,CAAC,CAED;AACA,KAAM,CAAAgB,WAAW,CAAGA,CAAA,GAAM,CACxBpC,QAAQ,CACNC,KAAK,CAACJ,QAAQ,CAAC,CACZK,IAAI,CAAC,IAAI,CAAC,CACVC,GAAG,CAAC,IAAMF,KAAK,CAACJ,QAAQ,CAAC,CAACK,IAAI,CAAC,IAAI,CAAC,CACzC,CAAC,CACDG,UAAU,CAAC,IAAI,CAAC,CAChBE,SAAS,CAAC,IAAI,CAAC,CACfE,SAAS,CAAC,KAAK,CAAC,CAClB,CAAC,CAED,mBACEjB,KAAA,QAAA6C,QAAA,eACE7C,KAAA,OAAA6C,QAAA,EAAI,aACS,CAACxC,QAAQ,CAAC,gBAAc,CAACC,SAAS,EAC3C,CAAC,cACLJ,IAAA,CAACL,KAAK,EAACU,KAAK,CAAEA,KAAM,CAACuC,OAAO,CAAExB,WAAY,CAAE,CAAC,cAC7CpB,IAAA,CAACJ,MAAM,EACLgB,MAAM,CAAEA,MAAO,CACfE,MAAM,CAAEA,MAAO,CACfJ,OAAO,CAAEA,OAAQ,CACjBmC,OAAO,CAAEH,WAAY,CACtB,CAAC,EACC,CAAC,CAEV,CAAC,CAED,cAAe,CAAAzC,IAAI","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}